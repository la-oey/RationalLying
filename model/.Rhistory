match(r.l, r.r)
B.R = 0.2
B.r = 0.2
match(r.l, r.r) * B.r
s = 2
match <- function(l, r){
b*(l/r)^s
}
match(r.l, r.r) * B.r
match(r.l, r.r)
1/(match(r.l, r.r)+1)
b = 1
s = 2
r.l = 0.8
r.r = 0.2
match <- function(l, r){
b*(l/r)^s
}
B.r = 1/(match(r.l, r.r)+1)
B.l = 1 - B.r
c(B.l, B.r)
b = 1
s = 1
r.l = 0.8
r.r = 0.2
match <- function(l, r){
b*(l/r)^s
}
B.r = 1/(match(r.l, r.r)+1)
B.l = 1 - B.r
c(B.l, B.r)
r.r = seq(10,0,-0.1)
r.r
r.l = seq(0,1,0.1)
r.r = seq(1,0,-0.1)
r.r
match <- function(b, s){
rat <- b*(r.l/r.r)^s
return(1 - 1/(rat+1))
}
match(1,1)
plot(r.l, match(1,1))
plot(r.l, match(1,2))
plot(r.l, match(1,3))
plot(r.l, match(1,5))
plot(r.l, match(2,5))
plot(r.l, match(2,1))
plot(r.l, match(3,1))
plot(r.l, match(4,1))
plot(r.l, match(1,0.5))
plot(r.l, match(1,5))
plot(r.l, match(1,0.2))
plot(r.l, match(1,-5))
plot(r.l, match(4,0.2))
plot(r.l, match(1,0.2))
plot(r.l, match(1,0))
m = c(rep(1,5), rep(2,5))
d = rep(c(0,5,10,30,60), each=2)
m = c(rep(1,5), rep(2,5))
d = rep(c(0,5,10,30,60), each=2)
val <- function(k){
m / (1 + k*d)
}
value(2)
val(2)
c(rep(1,5), rep(2,5))
d = rep(c(0,5,10,30,60), 2)
data.frame(mag = m,
delay = d,
val = val(1))
ggplot(data.frame(mag = m,
delay = d,
val = val(1)),
aes(x=d, y=val, colour=m)) +
geom_point() +
geom_line()
library(tidyverse)
ggplot(data.frame(mag = m,
delay = d,
val = val(1)),
aes(x=d, y=val, colour=m)) +
geom_point() +
geom_line()
ggplot(data.frame(mag = as.factor(m),
delay = d,
val = val(1)),
aes(x=d, y=val, colour=m)) +
geom_point() +
geom_line()
m
data.frame(mag = as.factor(m),
delay = d,
val = val(1)) %>%
mutate(mag = as.factor(m)) %>%
ggplot(aes(x=d, y=val, colour=m)) +
geom_point() +
geom_line()
data.frame(mag = as.factor(m),
delay = d,
val = val(1)) %>%
mutate(mag = as.factor(m))
data.frame(mag = m,
delay = d,
val = val(1)) %>%
mutate(mag = as.factor(mag)) %>%
ggplot(aes(x=d, y=val, colour=m)) +
geom_point() +
geom_line()
data.frame(mag = m,
delay = d,
val = val(1)) %>%
mutate(mag = as.factor(mag))
tibble(mag = m,
delay = d,
val = val(1)) %>%
mutate(mag = as.factor(mag)) %>%
ggplot(aes(x=d, y=val, colour=m)) +
geom_point() +
geom_line()
tibble(mag = m,
delay = d,
val = val(1)) %>%
mutate(mag = as.factor(mag))
tibble(mag = m,
delay = d,
val = val(1)) %>%
mutate(mag = as.factor(mag)) %>%
ggplot(aes(x=d, y=val, colour=m)) +
geom_point() +
geom_line() +
scale_colour_discrete(values=c("red","blue"))
tibble(mag = m,
delay = d,
val = val(1)) %>%
mutate(mag = as.factor(mag)) %>%
ggplot(aes(x=d, y=val, colour=m)) +
geom_point() +
geom_line() +
scale_colour_manual(values=c("red","blue"))
tibble(mag = m,
delay = d,
val = val(1)) %>%
mutate(mag = as.factor(mag))
tibble(mag = m,
delay = d,
val = val(1)) %>%
mutate(mag = factor(mag)) %>%
ggplot(aes(x=d, y=val, colour=m)) +
geom_point() +
geom_line() +
scale_colour_manual(values=c("red","blue"))
tibble(mag = m,
delay = d,
val = val(1)) %>%
mutate(mag = factor(mag)) %>%
ggplot(aes(x=d, y=val, colour=m)) +
geom_point() +
geom_line()
tibble(mag = m,
delay = d,
val = val(1)) %>%
mutate(mag = paste0("mag",mag)) %>%
ggplot(aes(x=d, y=val, colour=m)) +
geom_point() +
geom_line() +
scale_colour_manual(values=c("red","blue"))
tibble(mag = m,
delay = d,
val = val(1)) %>%
mutate(mag = paste0("mag",mag)) %>%
ggplot(aes(x=d, y=val, colour=m)) +
geom_point() +
geom_line()
tibble(mag = m,
delay = d,
val = val(1)) %>%
mutate(mag = paste0("mag",mag))
tibble(mag = m,
delay = d,
val = val(1)) %>%
mutate(mag = as.factor(mag)) %>%
ggplot(aes(x=d, y=val, colour=mag)) +
geom_point() +
geom_line() +
scale_colour_manual(values=c("red","blue"))
tibble(mag = m,
delay = d,
val = val(5)) %>%
mutate(mag = as.factor(mag)) %>%
ggplot(aes(x=d, y=val, colour=mag)) +
geom_point() +
geom_line() +
scale_colour_manual(values=c("red","blue"))
tibble(mag = m,
delay = d,
val = val(0.1)) %>%
mutate(mag = as.factor(mag)) %>%
ggplot(aes(x=d, y=val, colour=mag)) +
geom_point() +
geom_line() +
scale_colour_manual(values=c("red","blue"))
library(tidyverse)
library(lme4)
library(lmerTest)
knitr::opts_chunk$set(echo = TRUE)
raw.red <- read_csv("red_raw.csv")
raw.blue <- read_csv("blue_raw.csv")
load("Rdata/noToMfit.Rdata")
load("Rdata/recurseToMfit.Rdata")
my_red = c("#ffd5d6","#fc7f81","#fd2428")
glimpse(raw.red)
raw <- raw.red %>%
mutate(util = "red") %>%
bind_rows(mutate(raw.blue, util="blue"))
raw %>%
distinct(subjID, util, probabilityRed) %>%
count(util,probabilityRed)
length(unique(raw$subjID))
exclude.sampling <- raw %>%
filter(reportedDrawn > 10 | drawnRed > 10) %>%
.$subjID
exclude.catch <- raw %>%
filter(catchKey != -1) %>%
group_by(subjID) %>%
# summarise(catchAcc = sum(abs(catchResponse - catchKey) <= 1)/n()) %>% # less strict criteria
summarise(catchAcc = sum(catchResponse == catchKey)/n()) %>%
filter(catchAcc <= .75) %>%
pull(subjID)
length(exclude.catch)
# exclude.catch.b <- raw %>% #original, err
#   filter(catchKey != -1, util=="blue") %>%
#   group_by(subjID) %>%
#   summarise(catchAcc = sum(abs(catchResponse - catchKey) <= 1)/n()) %>%
#   filter(catchAcc <= .75) %>%
#   pull(subjID)
# exclude.catch.r <- raw %>% #
#   filter(catchKey != -1, util=="red") %>%
#   group_by(subjID) %>%
#   summarise(catchAcc = sum(catchResponse == catchKey)/n()) %>%
#   filter(catchAcc <= .75) %>%
#   pull(subjID)
df <- raw %>%
filter(exptPart == "trial") %>%
filter(!subjID %in% exclude.sampling) %>%
filter(!subjID %in% exclude.catch) %>%
# filter(!subjID %in% exclude.catch.b) %>%
# filter(!subjID %in% exclude.catch.r) %>%
rename(role = roleCurrent,
p = probabilityRed,
k = drawnRed,
ksay = reportedDrawn) %>%
mutate(role = ifelse(role == "bullshitter", "sender", "receiver"),
util = factor(util, levels=c("red", "blue"))) %>%
select(c(subjID, trialNumber, role, util, p, k, ksay, callBS)) %>%
mutate(lie = as.numeric(k != ksay))
length(unique(df$subjID))
expt.S.full <- df %>% filter(role == "sender")
expt.R.full <- df %>% filter(role == "receiver")
setwd("/Users/loey/Desktop/Research/RationalLying/model/")
source("ToMModelFunctions.R")
models.sources = paste0("modelFuncs/",list.files("modelFuncs"))
sapply(models.sources, source)
library(stats4)
humanLie <- expt.S.full
humanDetect <- expt.R.full
logitToProb <- function(logit){
exp(logit) / (1+exp(logit))
}
probToLogit <- function(prob){
log(prob / (1 - prob))
}
# 121 x 6 matrix
# humanLieCounts <- humanLie %>%
#   count(expt, probabilityRed, drawnRed, reportedDrawn) %>%
#   complete(expt=c("expt4","expt5"), probabilityRed=c(0.2,0.5,0.8), drawnRed=0:10, reportedDrawn=0:10, fill = list(n = 0)) %>%
#   pull(n) %>%
#   matrix(nrow=121)
humanLieCounts <- humanLie %>%
count(p, k, ksay) %>%
complete(p=c(0.2,0.5,0.8), k=0:10, ksay=0:10, fill = list(n = 0)) %>%
pull(n) %>%
matrix(nrow=121)
# 22 x 6 matrix
# humanDetectCounts <- humanDetect %>%
#   count(expt, probabilityRed, reportedDrawn, callBS) %>%
#   complete(expt=c("expt4","expt5"), probabilityRed=c(0.2,0.5,0.8), reportedDrawn=0:10, callBS=c(TRUE,FALSE), fill = list(n = 0))
humanDetectCounts <- humanDetect %>%
count(p, ksay, callBS) %>%
complete(p=c(0.2,0.5,0.8), ksay=0:10, callBS=c(TRUE,FALSE), fill = list(n = 0))
humanDetectCounts.T <- humanDetectCounts %>%
filter(callBS) %>%
pull(n) %>%
matrix(nrow=11)
humanDetectCounts.F <- humanDetectCounts %>%
filter(!callBS) %>%
pull(n) %>%
matrix(nrow=11)
# get diagonal of a 3 dimensional array
getDiag <- function(arr){
apply(arr, MARGIN=3, FUN=diag)
}
select_all_but_diag <- function(x) {
matrix(x[lower.tri(x, diag = F) | upper.tri(x, diag = F)],
nrow = nrow(x) - 1,
ncol = ncol(x))
}
getLies <- function(arr){
apply(arr, MARGIN=3, FUN=select_all_but_diag)
}
eval.s <- function(matr, ns){ #ns = 121 x 6 matrix of counts for all conditions
sum(log(matr)*ns)
}
eval.r <- function(matr, ns.T, ns.F){ #ns = 11 x 6 matrix of counts for all conditions
sum(log(matr)*ns.T + log(1-matr)*ns.F)
}
st = 1
end = 6
modelsEval = list(
# # # # # # # #
# # no ToM # #
# # # # # # # #
noToM = function(){
print("no ToM")
noToM.LL <- function(alph, eta.S, eta.R, weight){
ns.l = array(humanLieCounts, dim=c(11,11,6))
ns.T = humanDetectCounts.T
ns.F = humanDetectCounts.F
noToM.mat <- list(noToM.s.pred(alph, eta.S, weight), noToM.r.pred(alph, eta.R))
s.eval = -eval.s(noToM.mat[[1]][,,st:end], ns.l[,,st:end])
r.eval = -eval.r(noToM.mat[[2]][,st:end], ns.T[,st:end], ns.F[,st:end])
print(paste("alph =", alph, "; eta.S =", eta.S, "; weight =", logitToProb(weight), "; r =", r.eval, "; s =", s.eval))
neg.log.lik = r.eval + s.eval
neg.log.lik + abs(weight)
}
noToM.fit <- summary(mle(noToM.LL,
start=list(alph=rnorm(1, 1, 0.2),
eta.S=rnorm(1, 0, 1),
eta.R=rnorm(1, 0, 1),
weight=rnorm(1, 0, 1)),
method = "BFGS"))
noToM.fit
},
# # # # # # # # # # #
# # recursive ToM # #
# # # # # # # # # # #
recurseToM = function(){
print("recursive ToM")
recurseToM.LL <- function(alph, eta.S, eta.R, lambda, weight){
ns.l = array(humanLieCounts, dim=c(11,11,6))
ns.T = humanDetectCounts.T
ns.F = humanDetectCounts.F
recurseToM.mat <- recurseToM.pred(alph, eta.S, eta.R, lambda, weight)
r.eval = -eval.r(recurseToM.mat[[1]][,st:end], ns.T[,st:end], ns.F[,st:end])
s.eval = -eval.s(recurseToM.mat[[2]][,,st:end], ns.l[,,st:end])
print(paste("alph =", alph, "; weight =", logitToProb(weight), "; lambda =", lambda, "; r =", r.eval, "; s =", s.eval))
neg.log.lik = r.eval + s.eval
neg.log.lik + abs(weight) #weight^2?
}
recurseToM.fit <- summary(mle(recurseToM.LL,
start=list(alph=rnorm(1, 1, 0.2),
eta.S=rnorm(1, 0, 1),
eta.R=rnorm(1, 0, 1),
lambda=rnorm(1, 0, 1),
weight=rnorm(1, 0, 1)),
method = "BFGS"))
recurseToM.fit
},
# # # # # # # # # # # #
# # everybody lies # #
# # # # # # # # # # # #
everybodyLies = function(){
print("everybody lies")
everybodyLies.LL <- function(lambda, weight){
ns.l = humanLieCounts
-eval.s(
everybodyLies.pred(lambda, weight)[,st:end],
ns.l[,st:end]
)
}
everybodyLies.fit <- summary(mle(everybodyLies.LL,
start=list(lambda=rnorm(1, 0, 1),
weight=rnorm(1, 0, 1)),
method = "BFGS"))
everybodyLies.fit
},
# # # # # # # # # # # #
# # some people lie # #
# # # # # # # # # # # #
someLies = function(){
print("some people lie")
someLies.LL <- function(pTrue, lambda, weight){
ns.l = humanLieCounts
-eval.s(
someLies.pred(pTrue, lambda, weight)[,st:end],
ns.l[,st:end]
)
}
someLies.fit <- summary(mle(someLies.LL,
start=list(pTrue=rnorm(1,0,1),
lambda=rnorm(1, 0, 1),
weight=rnorm(1, 0, 1)),
method = "BFGS"))
someLies.fit
}
)
start_time <- Sys.time()
noToMeval = modelsEval$noToM()
print(Sys.time() - start_time)
humanDetectCounts.T
end = 3
modelsEval = list(
# # # # # # # #
# # no ToM # #
# # # # # # # #
noToM = function(){
print("no ToM")
noToM.LL <- function(alph, eta.S, eta.R, weight){
ns.l = array(humanLieCounts, dim=c(11,11,6))
ns.T = humanDetectCounts.T
ns.F = humanDetectCounts.F
noToM.mat <- list(noToM.s.pred(alph, eta.S, weight), noToM.r.pred(alph, eta.R))
s.eval = -eval.s(noToM.mat[[1]][,,st:end], ns.l[,,st:end])
r.eval = -eval.r(noToM.mat[[2]][,st:end], ns.T[,st:end], ns.F[,st:end])
print(paste("alph =", alph, "; eta.S =", eta.S, "; weight =", logitToProb(weight), "; r =", r.eval, "; s =", s.eval))
neg.log.lik = r.eval + s.eval
neg.log.lik + abs(weight)
}
noToM.fit <- summary(mle(noToM.LL,
start=list(alph=rnorm(1, 1, 0.2),
eta.S=rnorm(1, 0, 1),
eta.R=rnorm(1, 0, 1),
weight=rnorm(1, 0, 1)),
method = "BFGS"))
noToM.fit
},
# # # # # # # # # # #
# # recursive ToM # #
# # # # # # # # # # #
recurseToM = function(){
print("recursive ToM")
recurseToM.LL <- function(alph, eta.S, eta.R, lambda, weight){
ns.l = array(humanLieCounts, dim=c(11,11,6))
ns.T = humanDetectCounts.T
ns.F = humanDetectCounts.F
recurseToM.mat <- recurseToM.pred(alph, eta.S, eta.R, lambda, weight)
r.eval = -eval.r(recurseToM.mat[[1]][,st:end], ns.T[,st:end], ns.F[,st:end])
s.eval = -eval.s(recurseToM.mat[[2]][,,st:end], ns.l[,,st:end])
print(paste("alph =", alph, "; weight =", logitToProb(weight), "; lambda =", lambda, "; r =", r.eval, "; s =", s.eval))
neg.log.lik = r.eval + s.eval
neg.log.lik + abs(weight) #weight^2?
}
recurseToM.fit <- summary(mle(recurseToM.LL,
start=list(alph=rnorm(1, 1, 0.2),
eta.S=rnorm(1, 0, 1),
eta.R=rnorm(1, 0, 1),
lambda=rnorm(1, 0, 1),
weight=rnorm(1, 0, 1)),
method = "BFGS"))
recurseToM.fit
},
# # # # # # # # # # # #
# # everybody lies # #
# # # # # # # # # # # #
everybodyLies = function(){
print("everybody lies")
everybodyLies.LL <- function(lambda, weight){
ns.l = humanLieCounts
-eval.s(
everybodyLies.pred(lambda, weight)[,st:end],
ns.l[,st:end]
)
}
everybodyLies.fit <- summary(mle(everybodyLies.LL,
start=list(lambda=rnorm(1, 0, 1),
weight=rnorm(1, 0, 1)),
method = "BFGS"))
everybodyLies.fit
},
# # # # # # # # # # # #
# # some people lie # #
# # # # # # # # # # # #
someLies = function(){
print("some people lie")
someLies.LL <- function(pTrue, lambda, weight){
ns.l = humanLieCounts
-eval.s(
someLies.pred(pTrue, lambda, weight)[,st:end],
ns.l[,st:end]
)
}
someLies.fit <- summary(mle(someLies.LL,
start=list(pTrue=rnorm(1,0,1),
lambda=rnorm(1, 0, 1),
weight=rnorm(1, 0, 1)),
method = "BFGS"))
someLies.fit
}
)
start_time <- Sys.time()
noToMeval = modelsEval$noToM()
print(Sys.time() - start_time)
start_time <- Sys.time()
for(i in 1:20){
tryCatch({
recurseToMeval = modelsEval$recurseToM()
break
}, error = function(e){
message(e)
})
}
print(Sys.time() - start_time)
save(recurseToMeval, file="../analysis/Rdata/recurseToMfit.Rdata")
